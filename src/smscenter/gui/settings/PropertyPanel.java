/*
 * PropertyPanel.java
 *
 * Created on 3. Januar 2007, 21:04
 */

package smscenter.gui.settings;

import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author  Administrator
 */
public class PropertyPanel extends javax.swing.JPanel {
    
    /** Creates new form PropertyPanel */
    public PropertyPanel() {
        initComponents();
    }
    
    public void setObject(Object obj, final boolean editable, final boolean inherit) {
        final Object[] columnNames = new String[] {
            java.util.ResourceBundle.getBundle("smscenter/gui/resources/SMSCenter")
                .getString("propertyNameLabel"),
            java.util.ResourceBundle.getBundle("smscenter/gui/resources/SMSCenter")
                .getString("propertyValueLabel")
        };
        
        final List<Object[]> rows = new java.util.ArrayList<>();
        
        fillRows(rows, obj, obj.getClass(), inherit);
        
        table.setModel(
            new javax.swing.table.AbstractTableModel() {
                @Override
                public String getColumnName(int column) { return columnNames[column].toString(); }

                @Override
                public int getRowCount() { return rows.size(); }
                
                @Override
                public int getColumnCount() { return columnNames.length; }

                @Override
                public Object getValueAt(int row, int col) { return rows.get(row)[col]; }
                
                @Override
                public boolean isCellEditable(int row, int column) {
                    return editable && column > 0;
                }
                
                @Override
                public void setValueAt(Object value, int row, int col) {
                    if (rows.get(row)[col] instanceof Integer)
                        rows.get(row)[col] = new Integer(value.toString());
                    else
                        rows.get(row)[col] = value;
                    fireTableCellUpdated(row, col);
                }
        });
    }
    
    
    private void fillRows(List<Object[]> rows, Object obj, Class clazz, boolean inherit) {
        
        if (clazz.getName().equals("java.lang.Object"))
            return;
        
        if (inherit && clazz.getSuperclass() != null)
            fillRows(rows, obj, clazz.getSuperclass(), inherit);
        
        java.lang.reflect.Field fields[] = clazz.getDeclaredFields();
        
        for (int idx = 0; idx < fields.length; idx++) {
            Object[] row = new Object[2];
                        
            char[] c = fields[idx].getName().toCharArray();
            c[0] = Character.toUpperCase(c[0]);
            
            String name = new String(c);

            java.lang.reflect.Method method = null;

            // First try: getXxx pattern
            try {
                method = obj.getClass().getMethod("get" + name);
            } catch (NoSuchMethodException e) {
                // Boolean methods might have a isXxx pattern
                try {
                    method = obj.getClass().getMethod("is" + name);
                } catch (NoSuchMethodException e2) {
                    // Keine Property
                    Logger.getLogger(getClass().getName()).log(Level.FINE, "Not a property: " + name);
                    continue;
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            
            try {
                if (method != null) {
                    row[0] = name;
                    row[1] = method.invoke(obj);

                    if (row[1] == null) {
                        row[1] = method.getReturnType().newInstance();
                    }

                    // TODO: Wenn Wert ein Object oder Array ist, als String formatieren.
                    // Aber wie kann man das Object wieder deserialisieren?

/*
                    if (row[1].getClass().isArray()) {
                        row[1] = json.toJson(row[1]);
                    }
*/                    
                    
                    rows.add(row);
                }
            } catch (Exception e) {
                Logger.getLogger(getClass().getName()).log(Level.SEVERE, null, e);
            }
        }
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        scrollPane = new javax.swing.JScrollPane();
        table = new javax.swing.JTable() {
            public javax.swing.table.TableCellRenderer getCellRenderer(int row, int col) {
                Object value = getModel().getValueAt(row, col);
                if (value == null)
                return super.getCellRenderer(row, col);
                else if (value instanceof Boolean)
                return getDefaultRenderer(Boolean.class);
                else
                return super.getCellRenderer(row, col);
            }

            public javax.swing.table.TableCellEditor getCellEditor(int row, int col) {
                Object value = getModel().getValueAt(row, col);
                if (value == null)
                return super.getCellEditor(row, col);
                else if (value instanceof Boolean)
                return getDefaultEditor(Boolean.class);
                else if (value instanceof Enum) {
                    try {
                        Object[] values = (Object[]) (value.getClass().getMethod("values").invoke(null));
                        return new javax.swing.DefaultCellEditor(new javax.swing.JComboBox(values));
                    } catch (Exception e) {
                        return super.getCellEditor(row, col);
                    }
                }
                else
                return super.getCellEditor(row, col);
            }
        };

        table.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {

            }
        ));
        scrollPane.setViewportView(table);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(scrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(scrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 355, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    void updateObject(Object obj) {
        for (int row = 0; row < table.getModel().getRowCount(); row++) {
            String name = table.getModel().getValueAt(row, 0).toString();
            Object value = table.getModel().getValueAt(row, 1);

            if (value == null)
                continue;
            
            try {
                Class clazz = value.getClass();
                if (clazz == Boolean.class)
                    clazz = Boolean.TYPE;
                else if (clazz == Byte.class)
                    clazz = Byte.TYPE;
                else if (clazz == Character.class)
                    clazz = Character.TYPE;
                else if (clazz == Short.class)
                    clazz = Short.TYPE;
                else if (clazz == Integer.class)
                    clazz = Integer.TYPE;
                else if (clazz == Long.class)
                    clazz = Long.TYPE;                    
                else if (clazz == Float.class)
                    clazz = Float.TYPE;
                else if (clazz == Double.class)
                    clazz = Double.class;

                java.lang.reflect.Method method = obj.getClass().getMethod("set" + name, clazz);
                method.invoke(obj, value);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane scrollPane;
    private javax.swing.JTable table;
    // End of variables declaration//GEN-END:variables
}
